================================================================================
Firebase統合とデータ同期
================================================================================

Phase 2: Firebase統合の準備
-------------------------
要件定義:
- 複数デバイス間でのデータ同期
- ユーザー認証によるデータ分離
- リアルタイムでのデータ更新
- オフライン対応

実装工程:

1. Firebase設定の実装

Firebase初期化ファイルの作成:
// lib/firebase.ts
import { initializeApp } from 'firebase/app'
import { getFirestore } from 'firebase/firestore'
import { getAuth } from 'firebase/auth'

const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID
}

const app = initializeApp(firebaseConfig)
export const db = getFirestore(app)
export const auth = getAuth(app)
export default app

認証コンテキストの実装:
// components/auth-provider.tsx
'use client'

import { createContext, useContext, useEffect, useState } from 'react'
import { User, signInAnonymously, onAuthStateChanged } from 'firebase/auth'
import { auth } from '@/lib/firebase'

interface AuthContextType {
  user: User | null
  loading: boolean
  error: string | null
}

const AuthContext = createContext<AuthContextType>({
  user: null,
  loading: true,
  error: null
})

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, async (user) => {
      if (user) {
        setUser(user)
      } else {
        // 匿名認証でサインイン
        try {
          await signInAnonymously(auth)
        } catch (err) {
          setError('認証エラーが発生しました')
          console.error('Auth error:', err)
        }
      }
      setLoading(false)
    })

    return () => unsubscribe()
  }, [])

  return (
    <AuthContext.Provider value={{ user, loading, error }}>
      {children}
    </AuthContext.Provider>
  )
}

export const useAuth = () => useContext(AuthContext)

2. データ同期機能の実装

同期ライブラリの作成:
// lib/sync.ts
import { 
  doc, 
  setDoc, 
  getDoc, 
  collection, 
  query, 
  where, 
  onSnapshot,
  deleteDoc,
  updateDoc,
  serverTimestamp 
} from 'firebase/firestore'
import { db } from '@/lib/firebase'

// 型定義の拡張
export interface Project {
  id: string
  name: string
  description?: string
  createdAt: string
  updatedAt: string
  userId: string
  isShared?: boolean
  shareToken?: string
  sharedAt?: string
  allowEdit?: boolean
}

export interface MonthlyData {
  categories: Category[]
  expenses: Expense[]
}

export interface ProjectData {
  [monthKey: string]: MonthlyData
}

// プロジェクト同期機能
export const syncProjects = {
  // プロジェクトの取得
  async get(userId: string): Promise<Project[]> {
    try {
      const projectsRef = collection(db, 'projects')
      const q = query(projectsRef, where('userId', '==', userId))
      const snapshot = await getDocs(q)
      
      return snapshot.docs.map(doc => {
        const data = doc.data()
        return {
          id: doc.id,
          name: data.name || '',
          description: data.description || '',
          createdAt: data.createdAt?.toDate?.()?.toISOString() || new Date().toISOString(),
          updatedAt: data.updatedAt?.toDate?.()?.toISOString() || new Date().toISOString(),
          userId: data.userId || userId,
          isShared: data.isShared || false,
          shareToken: data.shareToken || '',
          sharedAt: data.sharedAt?.toDate?.()?.toISOString() || '',
          allowEdit: data.allowEdit || false
        }
      })
    } catch (error) {
      console.error('Error fetching projects:', error)
      return []
    }
  },

  // プロジェクトの保存
  async save(project: Project): Promise<void> {
    try {
      const projectRef = doc(db, 'projects', project.id)
      await setDoc(projectRef, {
        ...project,
        updatedAt: serverTimestamp()
      })
    } catch (error) {
      console.error('Error saving project:', error)
      throw error
    }
  },

  // プロジェクトの削除
  async delete(projectId: string): Promise<void> {
    try {
      const projectRef = doc(db, 'projects', projectId)
      await deleteDoc(projectRef)
    } catch (error) {
      console.error('Error deleting project:', error)
      throw error
    }
  },

  // リアルタイム監視
  subscribe(userId: string, callback: (projects: Project[]) => void) {
    const projectsRef = collection(db, 'projects')
    const q = query(projectsRef, where('userId', '==', userId))
    
    return onSnapshot(q, (snapshot) => {
      const projects = snapshot.docs.map(doc => {
        const data = doc.data()
        return {
          id: doc.id,
          name: data.name || '',
          description: data.description || '',
          createdAt: data.createdAt?.toDate?.()?.toISOString() || new Date().toISOString(),
          updatedAt: data.updatedAt?.toDate?.()?.toISOString() || new Date().toISOString(),
          userId: data.userId || userId,
          isShared: data.isShared || false,
          shareToken: data.shareToken || '',
          sharedAt: data.sharedAt?.toDate?.()?.toISOString() || '',
          allowEdit: data.allowEdit || false
        }
      })
      callback(projects)
    })
  }
}

// プロジェクトデータ同期機能
export const syncProjectData = {
  // プロジェクトデータの取得
  async get(projectId: string): Promise<ProjectData> {
    try {
      const dataRef = doc(db, 'projectData', projectId)
      const snapshot = await getDoc(dataRef)
      
      if (snapshot.exists()) {
        const data = snapshot.data()
        // データの検証とクリーンアップ
        const cleanedData: ProjectData = {}
        Object.entries(data).forEach(([key, value]) => {
          if (/^\d{4}-\d{2}$/.test(key) && value && typeof value === 'object') {
            const monthlyData = value as any
            if (monthlyData.categories && monthlyData.expenses) {
              cleanedData[key] = {
                categories: Array.isArray(monthlyData.categories) ? monthlyData.categories : [],
                expenses: Array.isArray(monthlyData.expenses) ? monthlyData.expenses : []
              }
            }
          }
        })
        return cleanedData
      }
      return {}
    } catch (error) {
      console.error('Error fetching project data:', error)
      return {}
    }
  },

  // プロジェクトデータの保存
  async save(projectId: string, data: ProjectData): Promise<void> {
    try {
      const dataRef = doc(db, 'projectData', projectId)
      // データの検証とクリーンアップ
      const cleanedData: ProjectData = {}
      Object.entries(data).forEach(([key, value]) => {
        if (/^\d{4}-\d{2}$/.test(key) && value && typeof value === 'object') {
          if (value.categories && value.expenses) {
            cleanedData[key] = {
              categories: Array.isArray(value.categories) ? value.categories : [],
              expenses: Array.isArray(value.expenses) ? value.expenses : []
            }
          }
        }
      })
      await setDoc(dataRef, cleanedData)
    } catch (error) {
      console.error('Error saving project data:', error)
      throw error
    }
  },

  // リアルタイム監視
  subscribe(projectId: string, callback: (data: ProjectData) => void) {
    const dataRef = doc(db, 'projectData', projectId)
    
    return onSnapshot(dataRef, (snapshot) => {
      if (snapshot.exists()) {
        const data = snapshot.data()
        // データの検証とクリーンアップ
        const cleanedData: ProjectData = {}
        Object.entries(data).forEach(([key, value]) => {
          if (/^\d{4}-\d{2}$/.test(key) && value && typeof value === 'object') {
            const monthlyData = value as any
            if (monthlyData.categories && monthlyData.expenses) {
              cleanedData[key] = {
                categories: Array.isArray(monthlyData.categories) ? monthlyData.categories : [],
                expenses: Array.isArray(monthlyData.expenses) ? monthlyData.expenses : []
              }
            }
          }
        })
        callback(cleanedData)
      } else {
        callback({})
      }
    })
  }
}

3. コンポーネントのFirebase統合

ProjectSelectorの更新:
// components/project-selector.tsx の更新部分
'use client'

import { useState, useEffect } from 'react'
import { useRouter } from 'next/navigation'
import { useAuth } from '@/components/auth-provider'
import { syncProjects } from '@/lib/sync'
import { Wifi, WifiOff } from 'lucide-react'

export default function ProjectSelector() {
  const [projects, setProjects] = useState<Project[]>([])
  const [isOnline, setIsOnline] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const { user } = useAuth()
  const router = useRouter()

  useEffect(() => {
    if (!user?.uid) return

    let unsubscribe: (() => void) | undefined

    const setupSync = async () => {
      try {
        setIsOnline(true)
        setError(null)
        
        // 初期データの読み込み
        const initialProjects = await syncProjects.get(user.uid)
        setProjects(initialProjects)

        // リアルタイム監視の設定
        unsubscribe = syncProjects.subscribe(user.uid, (updatedProjects) => {
          setProjects(updatedProjects)
        })
      } catch (err) {
        console.error('Sync setup error:', err)
        setError('データの同期に失敗しました')
        setIsOnline(false)
      }
    }

    setupSync()

    return () => {
      if (unsubscribe) {
        unsubscribe()
      }
    }
  }, [user?.uid])

  const createProject = async (name: string, description: string) => {
    if (!user?.uid) return

    const newProject: Project = {
      id: Date.now().toString(),
      name,
      description,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      userId: user.uid
    }

    try {
      await syncProjects.save(newProject)
    } catch (err) {
      console.error('Error creating project:', err)
      setError('プロジェクトの作成に失敗しました')
    }
  }

  const deleteProject = async (id: string) => {
    try {
      await syncProjects.delete(id)
    } catch (err) {
      console.error('Error deleting project:', err)
      setError('プロジェクトの削除に失敗しました')
    }
  }

  return (
    <div className="container mx-auto p-6">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold">プロジェクト一覧</h1>
        <div className="flex items-center gap-4">
          {isOnline ? (
            <div className="flex items-center gap-2 text-green-600">
              <Wifi className="h-4 w-4" />
              <span className="text-sm">同期中</span>
            </div>
          ) : (
            <div className="flex items-center gap-2 text-red-600">
              <WifiOff className="h-4 w-4" />
              <span className="text-sm">オフライン</span>
            </div>
          )}
          <Button onClick={() => setIsAddDialogOpen(true)}>
            <Plus className="h-4 w-4 mr-2" />
            新しいプロジェクト
          </Button>
        </div>
      </div>

      {error && (
        <div className="mb-4 p-4 bg-red-50 border border-red-200 rounded-lg">
          <p className="text-red-600">{error}</p>
        </div>
      )}

      {/* プロジェクト一覧の表示 */}
    </div>
  )
}

4. エラーハンドリングとデータ検証

データ検証の実装:
// lib/validation.ts
export function validateMonthlyData(data: any): data is MonthlyData {
  return (
    data &&
    typeof data === 'object' &&
    Array.isArray(data.categories) &&
    Array.isArray(data.expenses)
  )
}

export function validateProject(project: any): project is Project {
  return (
    project &&
    typeof project === 'object' &&
    typeof project.id === 'string' &&
    typeof project.name === 'string' &&
    typeof project.userId === 'string'
  )
}

export function cleanupProjectData(data: any): ProjectData {
  const cleaned: ProjectData = {}
  
  if (data && typeof data === 'object') {
    Object.entries(data).forEach(([key, value]) => {
      if (/^\d{4}-\d{2}$/.test(key) && validateMonthlyData(value)) {
        cleaned[key] = value
      }
    })
  }
  
  return cleaned
}

開発工程での学び
---------------
Firebase統合の複雑さ:
- 認証状態の管理
- リアルタイム同期の実装
- エラーハンドリングの重要性

データ検証の必要性:
- Firestoreからのデータ取得時の型安全性
- 不正なデータ構造への対応
- データクリーンアップの実装

オフライン対応の考慮:
- ネットワーク状態の監視
- エラー状態の表示
- ユーザーへの適切なフィードバック

セキュリティの実装:
- ユーザー固有のデータ分離
- Firestoreセキュリティルールの設定
- 認証によるアクセス制御

実装時の課題と解決
-----------------
1. 認証エラー（auth/invalid-api-key）:
- 課題: Firebase設定の環境変数が正しく設定されていない
- 解決: .env.localファイルの作成と環境変数の確認

2. Firestoreインデックスエラー:
- 課題: 複合クエリに必要なインデックスが存在しない
- 解決: Firebase Consoleでインデックスの作成

3. データ型エラー（forEach）:
- 課題: Firestoreからのデータが期待される型と異なる
- 解決: データ検証とクリーンアップ機能の実装

4. リアルタイム同期の複雑さ:
- 課題: 複数コンポーネントでの同期状態管理
- 解決: 統一された同期ライブラリの作成

次のステップ
-----------
Firebase統合が完了したので、次はプロジェクト共有機能の実装に進みます。URLベースの共有機能と共同編集機能を追加します。
